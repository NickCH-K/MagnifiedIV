% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factorPull.R
\name{factorPull}
\alias{factorPull}
\title{factorPull}
\usage{
factorPull(
  model,
  data,
  factor,
  interaction = NULL,
  specify = NULL,
  basevalue = 0,
  addterm = NULL,
  value = "estimate",
  na.predict = TRUE
)
}
\arguments{
\item{model}{A model object compatible with \code{broom::tidy()}.}

\item{data}{A data set containing the factor variable you want coefficients for.}

\item{factor}{A string with the name of the factor variable you'd like to get the coefficients of. Note if the variable is included in regression via the \code{factor()} function, include that. So if your model is \code{mpg~factor(cyl)+hp}, do \code{factor = 'factor(cyl)'}.}

\item{interaction}{A string with the name of a variable being interacted with \code{factor} for which you'd like to get the different interaction terms. Specify the name as it shows up in the regression table. So for example if \code{factor = 'X'} and your model has coefficients \code{Z1:X1, Z1:X2, Z2:X1, Z2:X2}, then \code{interaction = 'Z1'} will get the \code{Z1:X1, Z1:X2} coefficients.}

\item{specify}{For more complex sets of interactions, like three-way interactions, or if your \code{factor} variable is included via some function more complex than \code{factor()}, you can specify the exact naming structure of the coefficients, with \code{{value}} standing in for the factor value. So for example if you had coefficients \code{Z:X1:W, Z:X2:W} in your model, you could do \code{specify = 'Z:X{value}:W'}. This will override anything in \code{interaction}.}

\item{basevalue}{If \code{specify} is used, what value should the \code{factor} reference group (or any excluded terms) be given? By default \code{0}. Set to \code{NA} to leave omitted terms as \code{NA}.}

\item{addterm}{A string indicating a coefficient in the model to be added to all terms. Commonly this is the coefficient for the variable being interacted with, to give an overall effect of that variable, or \code{'(Intercept)'} to give a mean prediction.}

\item{value}{A string with the column name of the \code{broom::tidy()} result that you would like to extract. By default this is \code{value = 'estimate'} to get the coefficients.}

\item{na.predict}{Should observations in the data but not in the model, which do have nonmissing values of \code{factor}, be included in predictions? Setting this to \code{FALSE} requires that sending your \code{model} through \code{fitted()} produces a named vector.}
}
\description{
This function takes any estimated regression compatible with \code{broom::tidy()} that contains a factor variable, or a factor variable interacted with something else. It will pull out those coefficients and line them up with the original data so you can store them as a variable.
}
\details{
If multiple coefficients related to the factor are dropped from the model, be sure to check the result.
}
\examples{
df <- data.frame(w1 = rnorm(1000),
                 w2 = rnorm(1000),
                 e1 = rnorm(1000),
                 e2 = rnorm(1000),
                 z = rnorm(1000),
                 groups = factor(floor(0:999/100)))
df$x <- df$w1+df$w2+df$z+df$e1

# Create a model with an interaction between z and groups
lm_inx <- lm(x ~ z*groups + w1 + w2, data = df)

# Get the effect of z for each group
indivfx <- factorPull(lm_inx,
                      data = df,
                      factor = 'groups',
                      interaction = 'z',
                      addterm = 'z')

# Create a model with a fixed effect for groups
lm_inx2 <- lm(x ~ groups + z + w1 + w2, data = df)

# Get the fixed effect for each group, with 0 for the reference group
indivfe <- factorPull(lm_inx,
                      data = df,
                      factor = 'groups')
# Or add in the intercept to get the full fixed effect
indivfe2 <- factorPull(lm_inx,
                       data = df,
                       factor = 'groups',
                       addterm = '(Intercept)')
}
